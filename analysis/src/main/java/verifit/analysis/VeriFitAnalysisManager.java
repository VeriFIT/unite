// Start of user code Copyright
/*******************************************************************************
 * Copyright (c) 2011, 2012 IBM Corporation and others.
 *
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  and Eclipse Distribution License v. 1.0 which accompanies this distribution.
 *  
 *  The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 *  and the Eclipse Distribution License is available at
 *  http://www.eclipse.org/org/documents/edl-v10.php.
 *  
 *  Contributors:
 *  
 *	   Sam Padgett	       - initial API and implementation
 *     Michael Fiedler     - adapted for OSLC4J
 *     Jad El-khoury        - initial implementation of code generator (https://bugs.eclipse.org/bugs/show_bug.cgi?id=422448)
 *     Matthieu Helleboid   - Support for multiple Service Providers.
 *     Anass Radouani       - Support for multiple Service Providers.
 *
 * This file is generated by org.eclipse.lyo.oslc4j.codegenerator
 *******************************************************************************/
// End of user code

package verifit.analysis;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.ServletContextEvent;
import java.util.List;

import org.eclipse.lyo.oslc.domains.auto.AutomationPlan;
import org.eclipse.lyo.oslc.domains.auto.AutomationRequest;
import org.eclipse.lyo.oslc.domains.auto.AutomationResult;
import org.eclipse.lyo.oslc.domains.auto.Contribution;
import org.eclipse.lyo.oslc.domains.auto.ParameterDefinition;
import org.eclipse.lyo.oslc.domains.auto.ParameterInstance;
import verifit.analysis.automationPlans.AutomationPlanConfManager;
import verifit.analysis.resources.SUT;


// Start of user code imports
import verifit.analysis.persistance.Persistence;
import verifit.analysis.automationPlans.RequestRunner;
import verifit.analysis.automationPlans.SutAnalyse;
import verifit.analysis.exceptions.OslcResourceException;

import org.eclipse.lyo.store.StoreAccessException;
import org.eclipse.lyo.oslc4j.core.model.Link;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.wink.client.ClientResponse;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.stream.Stream;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.regex.Pattern;
import java.util.NoSuchElementException;
import java.util.Map;
import org.eclipse.lyo.client.oslc.OslcClient;
import verifit.analysis.automationPlans.AutomationPlanLoading;

import static verifit.analysis.utils.getResourceIdFromUri;
// End of user code

// Start of user code pre_class_code
// End of user code

public class VeriFitAnalysisManager {

    // Start of user code class_attributes
	
	static Persistence store;
	
	static ResourceIdGen AutoPlanIdGen;
	static ResourceIdGen AutoRequestIdGen;
	
	static RequestRunnerQueues AutoRequestQueues = new RequestRunnerQueues();

    // End of user code
    
    
    // Start of user code class_methods
	
	/**
	 * Used to generate IDs for new resources in a synchronized way (datarace free)
	 * @author od42
	 */
	private static class ResourceIdGen {
	    int idCounter; 
	    
	    public ResourceIdGen ()
	    {
	    	idCounter = 0;
	    };
	    
	    public ResourceIdGen (int start)
	    {
	    	idCounter = start;
	    }
	    
	    /**
	     * Get a new ID. This increments the internal ID counter. Synchronized.
	     * @return New ID
	     */
	    public synchronized String getId() {
	    	idCounter++;
	        return Integer.toString(idCounter - 1);
	    }
	}
	
	/**
	 * Check if a string is a console command by finding it in the system PATH
	 * source - https://stackoverflow.com/a/23539220
	 * @param command Command to look for
	 * @return	Whether the command is in the system PATH
	 */
	private static Boolean isInPath(String command)
	{
		return Stream.of(System.getenv("PATH").split(Pattern.quote(File.pathSeparator))).map(Paths::get).anyMatch(path -> Files.exists(path.resolve(command)));
	}

	/**
	 * Creates an AutomationPlan resource with the specified properties, and stores in the Adapter's catalog.
	 * @param aResource			The new resource will copy properties from the specified aResource.
	 * @return					The newly created resource. Or null if one of the required properties was missing.
	 * @throws StoreAccessException If the triplestore is not accessible
	 * @throws OslcResourceException If the AutomationPlan to be created is missing some properties or is invalid
	 */
    public static AutomationPlan createAutomationPlan(final AutomationPlan aResource) throws StoreAccessException, OslcResourceException
    {    	
    	AutomationPlan newResource = null;
    	
    	// check that required properties are specified
    	if (aResource == null)
    		throw new OslcResourceException("AutomationPlan creation failed: aResource was null");
    	
    	if (aResource.getTitle() == null || aResource.getTitle().isEmpty())
    	{
    		throw new OslcResourceException("AutomationPlan creation failed: dcterms:title missing or empty.");
    	}
    	if (aResource.getIdentifier() == null || aResource.getIdentifier().isEmpty())
    	{
    		throw new OslcResourceException("AutomationPlan creation failed: Title \"" + aResource.getTitle() + "\"- dcterms:identifier missing or empty.");
    	}
        
		try {
			String newID = aResource.getIdentifier();
			newResource = aResource;
			newResource.setAbout(VeriFitAnalysisResourcesFactory.constructURIForAutomationPlan(VeriFitAnalysisConstants.AUTOMATION_PROVIDER_ID, newID));
			
			// resources set by the service provider
			newResource.setIdentifier(newID);
			Date timestamp = new Date();
			newResource.setCreated(timestamp);
			newResource.setModified(timestamp);
			//newResource.setInstanceShape(new URI(VeriFitAnalysisProperties.PATH_RESOURCE_SHAPES + "automationPlan"));
			//newResource.addServiceProvider(new URI(VeriFitAnalysisProperties.PATH_AUTOMATION_SERVICE_PROVIDERS + serviceProviderId));
			//newResource.addType(new URI("http://open-services.net/ns/auto#AutomationPlan"));
			
			ParameterDefinition SUT = new ParameterDefinition();
			SUT.setDescription("Refference to an SUT resource to analyse. SUTs are created using the compilation provider."); //TODO
			SUT.setName("SUT");
			SUT.setOccurs(new Link(new URI(VeriFitAnalysisConstants.OSLC_OCCURS_ONE)));
			SUT.addValueType(new Link(new URI(VeriFitAnalysisConstants.OSLC_VAL_TYPE_STRING))); // TODO change to URI
			newResource.addParameterDefinition(SUT);

			ParameterDefinition outputFileRegex = new ParameterDefinition();
			outputFileRegex.setDescription("Files that change during execution and match this regex will "
					+ "be added as contributions to the Automation Result. The regex needs to match the "
					+ "whole filename."); //TODO
			outputFileRegex.setName("outputFileRegex");
			outputFileRegex.setOccurs(new Link(new URI(VeriFitAnalysisConstants.OSLC_OCCURS_ZEROorONE)));
			outputFileRegex.addValueType(new Link(new URI(VeriFitAnalysisConstants.OSLC_VAL_TYPE_STRING)));
			outputFileRegex.setDefaultValue(".^");
			newResource.addParameterDefinition(outputFileRegex);

			ParameterDefinition zipOutputs = new ParameterDefinition();
			zipOutputs.setDescription("If set to true, then all file contributions will be ZIPed and provided as a single zip contribution");
			zipOutputs.setName("zipOutputs");
			zipOutputs.setOccurs(new Link(new URI(VeriFitAnalysisConstants.OSLC_OCCURS_ZEROorONE)));
			zipOutputs.addValueType(new Link(new URI(VeriFitAnalysisConstants.OSLC_VAL_TYPE_BOOL)));
			zipOutputs.setDefaultValue("false");
			newResource.addParameterDefinition(zipOutputs);

			ParameterDefinition timeout = new ParameterDefinition();
			timeout.setDescription("Timeout for the analysis. Zero means no timeout.");
			timeout.setName("timeout");
			timeout.setOccurs(new Link(new URI(VeriFitAnalysisConstants.OSLC_OCCURS_ZEROorONE)));
			timeout.addValueType(new Link(new URI(VeriFitAnalysisConstants.OSLC_VAL_TYPE_INTEGER)));
			timeout.setDefaultValue("0");
			newResource.addParameterDefinition(timeout);

			ParameterDefinition toolCommand = new ParameterDefinition();
			toolCommand.setDescription("Used to omit the analysis tool launch command while executing analysis. True means the tool " + 
			"will be used and False means the tool command will not be used. (eg. \"./tool ./sut args\" vs \"/sut args\").");
			toolCommand.setName("toolCommand");
			toolCommand.setOccurs(new Link(new URI(VeriFitAnalysisConstants.OSLC_OCCURS_ZEROorONE)));
			toolCommand.addValueType(new Link(new URI(VeriFitAnalysisConstants.OSLC_VAL_TYPE_BOOL)));
			toolCommand.setDefaultValue("true");
			newResource.addParameterDefinition(toolCommand);
						
			// persist in the triplestore
			store.updateResources(new URI(VeriFitAnalysisProperties.SPARQL_SERVER_NAMED_GRAPH_RESOURCES), newResource);

		} catch (URISyntaxException e) {
			// TODO should never be thrown (URI syntax)
			e.printStackTrace();
			
		} catch (StoreAccessException e) {
			throw new StoreAccessException("AutomationPlan creation failed: " + e.getMessage());
		}
		
		return newResource;
    }
    

    /**
     * Updates an AutomationRequest in the Adapter's catalog. The old resource is replaced with the new one.
     * @param changedResource		This resource will be used as replacement for the old resource.
     * @param serviceProviderId		ID of the service provider for the updated resource.
     * @param automationRequestId	ID of the AutomationRequest to update
     * @return						The updated resource.
     */
    public static AutomationRequest updateAutomationRequest(AutomationRequest changedResource, final String serviceProviderId, final String automationRequestId)
    {
    	AutomationRequest updatedResource = null;

    	changedResource.setModified(new Date());
  
    	try {
    		
			store.updateResources(new URI(VeriFitAnalysisProperties.SPARQL_SERVER_NAMED_GRAPH_RESOURCES), changedResource);
			
		} catch (StoreAccessException e) {
			System.out.println("WARNING: AutomationRequest update failed: " + e.getMessage());
			
		} catch (URISyntaxException e) {
			// TODO should never be thrown (URI syntax)
			e.printStackTrace();
		}
    	updatedResource = changedResource;
    	
        return updatedResource;
    }
    
    /**
     * Updates an AutomationResult in the Adapter's catalog. The old resource is replaced with the new one.
     * @param changedResource		This resource will be used as replacement for the old resource.
     * @param serviceProviderId		ID of the service provider for the updated resource.
     * @param automationResultId	ID of the AutomationResult to update
     * @return						The updated resource.
     */
    public static AutomationResult updateAutomationResult(AutomationResult changedResource, final String serviceProviderId, final String automationResultId)
    {
    	AutomationResult updatedResource = null;

    	changedResource.setModified(new Date());
  
    	try {
    		
			store.updateResources(new URI(VeriFitAnalysisProperties.SPARQL_SERVER_NAMED_GRAPH_RESOURCES), changedResource);
			
		} catch (StoreAccessException e) {
			System.out.println("WARNING: AutomationResult update failed: " + e.getMessage());
			
		} catch (URISyntaxException e) {
			// TODO should never be thrown (URI syntax)
			e.printStackTrace();
		}
    	updatedResource = changedResource;
    	
        return updatedResource;
    }
    
    /**
     * Creates an AutomationResult resource with the specified properties, and stores in the Adapter's catalog.
     * @param aResource			The new resource will copy properties from the specified aResource.
     * @param serviceProviderId	ID of the service provider for the new resource.
     * @param newID				ID to assign to the new Result (meant to be the same as the Request ID)
     * @return					The newly created resource. Or null if one of the required properties was missing.
     */
    public static AutomationResult createAutomationResult(final AutomationResult aResource, final String serviceProviderId, final String newID)
    {
    	AutomationResult newResource = null;
    	
    	// check that required properties are specified in the input parameter
    	if (aResource == null || aResource.getTitle() == null || aResource.getTitle().isEmpty() ||
    		aResource.getState() == null || aResource.getState().isEmpty() ||
    		aResource.getVerdict() == null || aResource.getVerdict().isEmpty() ||
    		aResource.getReportsOnAutomationPlan().getValue() == null)
    	{
    		return null;
    	}
        
		try {
			newResource = aResource;
			aResource.setAbout(VeriFitAnalysisResourcesFactory.constructURIForAutomationResult(serviceProviderId, newID));
			
			// resources set by the service provider
			newResource.setIdentifier(newID);
			Date timestamp = new Date();
			newResource.setCreated(timestamp);
			newResource.setModified(timestamp);
			//newResource.setInstanceShape(new URI(VeriFitAnalysisProperties.PATH_RESOURCE_SHAPES + "automationResult"));
			//newResource.addServiceProvider(new URI(VeriFitAnalysisProperties.PATH_AUTOMATION_SERVICE_PROVIDERS + serviceProviderId));
			newResource.setDesiredState(new Link(new URI(VeriFitAnalysisConstants.AUTOMATION_STATE_COMPLETE)));
			//newResource.addType(new URI("http://open-services.net/ns/auto#AutomationResult"));
		
			// persist in the triplestore
			store.updateResources(new URI(VeriFitAnalysisProperties.SPARQL_SERVER_NAMED_GRAPH_RESOURCES), newResource);
			
		} catch (URISyntaxException e) {
			// TODO should never be thrown (URI syntax)
			e.printStackTrace();
			
		} catch (StoreAccessException e) {
			System.out.println("WARNING: AutomationResult creation failed: " + e.getMessage());
		}
		
		return newResource;
    }
    
	/**
	 * Check that the AutomationRequest contains the necessary input parameters based on its AutoPlan, fill the AutomationResult with output parameters (default values),
	 * and return a simplified map of parameters (TODO refactor the map)
	 * @param serviceProviderId			serviceProviderId passed by the HTTP request
	 * @param execAutoRequest			The AutomationRequest to execute. Needs to have a valid executesAutomationPlan property.
	 * @param newAutoResult				The AutomationResult created by the AutoRequest.
	 * @throws OslcResourceException 	When the executed AutomationRequest properties are invalid or missing
	 * @return	A map of input parameters [ name, Pair(value,position) ]; position -1 means there was no position
	 */
	private static Map<String, Pair<String,Integer>> processAutoReqInputParams(String serviceProviderId, AutomationRequest execAutoRequest, AutomationResult newAutoResult) throws OslcResourceException
	{
		// get the executed AutomationPlan resource			
		String execAutoPlanId = utils.getResourceIdFromUri(execAutoRequest.getExecutesAutomationPlan().getValue());
		AutomationPlan execAutoPlan = getAutomationPlan(null, serviceProviderId, execAutoPlanId);
		if (execAutoPlan == null)
			throw new OslcResourceException("AutomationPlan not found (id: " + execAutoPlanId + ")");

		/// check the input parameters and create a map of "name" -> ("value", position)
		Map<String, Pair<String,Integer>> inputParamsMap = new HashMap<String, Pair<String,Integer>>();
		
		// loop through autoPlan defined parameters to match them with the input params
		for (ParameterDefinition definedParam : execAutoPlan.getParameterDefinition())
		{
			Integer paramPosition;
			if (definedParam.getCommandlinePosition() != null)
			{
				paramPosition = definedParam.getCommandlinePosition();
			}
			else
			{
				paramPosition = -1;
			}
				
			// find the corresponding autoRequest input parameter
			boolean matched = false;
			for (ParameterInstance submittedParam : execAutoRequest.getInputParameter())
			{				
				if (definedParam.getName().equals(submittedParam.getName()))
				{
					
					// check if the value is allowed
					Boolean validValue = true;
					if (definedParam.getAllowedValue().size() > 0)
					{
						validValue = false;
						for (String allowedValue : definedParam.getAllowedValue())
						{
							if (allowedValue.equals(submittedParam.getValue()))
							{
								validValue = true;
								break;
							}
						}
					}
					if (!validValue)
					{
						throw new OslcResourceException("value '" + submittedParam.getValue() + "' not allowed for the '" + definedParam.getName() + "' parameter");
					}
					
					inputParamsMap.put(definedParam.getName(), Pair.of(submittedParam.getValue(),paramPosition));
					matched = true;
				}
			}
			// try to use the default value if no matching input param found
			if (!matched && definedParam.getDefaultValue() != null)
			{
				inputParamsMap.put(definedParam.getName(), Pair.of(definedParam.getDefaultValue(), paramPosition));
				matched = true;

				// add the default value as an output parameter to the Automation Result
				ParameterInstance outputParameter = null;
				try { outputParameter = new ParameterInstance(); } catch (URISyntaxException e) { /* should never be thrown --> just to make the compiler happy */}
				outputParameter.setName(definedParam.getName());
				outputParameter.setValue(definedParam.getDefaultValue());
				newAutoResult.addOutputParameter(outputParameter);
			}
			
			// check parameter occurrences
			Boolean paramMissing = false;
			switch (definedParam.getOccurs().getValue().toString())
			{
			case VeriFitAnalysisConstants.OSLC_OCCURS_ONE:
				// TODO check for more then one when there should be exactly one
			case VeriFitAnalysisConstants.OSLC_OCCURS_ONEorMany:
				if (!matched)
					paramMissing = true;
				break;
				
			case VeriFitAnalysisConstants.OSLC_OCCURS_ZEROorONE:
				// TODO check for more then one when there should be max one
				break;

			case VeriFitAnalysisConstants.OSLC_OCCURS_ZEROorMany:
				break;
			}
			
			if (paramMissing == true)
				throw new OslcResourceException("'" + definedParam.getName() + "' input parameter missing");
		}
		
		// check that there were no unknown input parameters
		for (ParameterInstance submittedParam : execAutoRequest.getInputParameter())
		{				
			boolean matched = false;
			for (ParameterDefinition definedParam : execAutoPlan.getParameterDefinition())
			{
				if (definedParam.getName().equals(submittedParam.getName()))
					matched = true;
			}
			
			if (!matched)
				throw new OslcResourceException("'" + submittedParam.getName() + "' input parameter not recognized");
		}
		
		return inputParamsMap;
	}    
    
	/**
     * TODO handmade because its abnormal (not as intended by lyo)
	 * @param httpServletRequest
	 * @param serviceProviderId
	 * @param contributionId
	 * @return
	 */
    public static File getContribution(HttpServletRequest httpServletRequest, final String serviceProviderId, final String contributionId)
    {
    	File aResource = null;

    	// decode slashes in the file path
		String filePath = contributionId.replaceAll("%2F", "/");
		
    	aResource = new File(filePath);

        return aResource;
    }
    
    /**
     * TODO handmade because its abnormal (not as intended by lyo)
     * @param httpServletRequest
     * @param aResource
     * @param serviceProviderId
     * @param contributionId
     * @return
     * @throws OslcResourceException
     */
    public static Contribution updateContribution(HttpServletRequest httpServletRequest, final Contribution aResource, final String serviceProviderId, final String contributionId) throws OslcResourceException {
        Contribution updatedResource = null;
        
        // Check that all the required properties are set
        if (aResource == null || aResource.getValue() == null)
        {
        	throw new OslcResourceException("Failed to write a Contribution file - Value missing");        	
        }

    	// decode slashes in the file path
		String filePath = contributionId.replaceAll("%2F", "/");
		
        // write the file - path is getPath and content is getValue
		try (PrintWriter out = new PrintWriter(filePath))
		{
		    out.print(aResource.getValue());
		} catch (IOException e)
		{
			throw new OslcResourceException("WARNING: Failed to write a Contribution file: " + e.getMessage());
		}
		
		updatedResource = aResource;	// TODO not changed and has no URI because its not GETable
		
        return updatedResource;
    }
    
    /**
     * A map of queues of Automation Request runners. Each queue is meant to be used for a different Automation Plan (key to the map).
     * The first runner in each queue will be started. 
     */
    public static class RequestRunnerQueues {
    	
    	private Map<String,List<RequestRunner>> queueMap;
    	
    	public RequestRunnerQueues()
    	{
    		queueMap = new HashMap<String,List<RequestRunner>>();
    	}

    	public synchronized Boolean queueExists(String queueName) 
    	{
    		return (queueMap.get(queueName) != null);
    	}
    	
    	public synchronized Boolean empty(String queueName) 
    	{
    		List<RequestRunner> queue = queueMap.get(queueName);
    		if(queue == null)
    			return true;
    		else
    			return queue.isEmpty();
    	}
    	
    	/**
    	 * Adds a runner into a named queue. The runner will be started when it reaches the front of the queue (immediately if the queue is empty).
    	 * @param queueName
    	 * @param runner
    	 */
    	public synchronized void queueUp(String queueName, RequestRunner runner)
    	{	
    		// check if the queue exists - create it if it doesnt
    		if (queueMap.get(queueName) == null)
    		{
    			queueMap.put(queueName, new LinkedList<RequestRunner>());
    		}
    		
    		// queue up
    		queueMap.get(queueName).add(runner);
    		
    		// start execution if first in line
    		if (queueMap.get(queueName).size() == 1)
    			runner.start();
    	}
    	
    	/**
    	 * Removes the first runner from a named queue. Meant to be called after the runner has finished execution. Will start the next runner in line.
    	 * @param queueName
    	 */
    	public synchronized void popFirst(String queueName)
    	{
    		List<RequestRunner> queue = queueMap.get(queueName);
    		if (!(queue == null)) // make sure the queue exists
    		{
    			queue.remove(0);
    			if (!(queue.isEmpty()))	// start the next runner if there is one
    				queue.get(0).start();
    		}
    	}
    };
    
    /**
     * Call this function at the end of an Automation Requests execution. If the request is part of a queue, then it will be removed from it and the next requets will start its execution.
     * @param req
     */
    public static void finishedAutomationRequestExecution(AutomationRequest req)
    {
    	String autoPlanId = utils.getResourceIdFromUri(req.getExecutesAutomationPlan().getValue());
    	
    	// if there is a request queue for this requests Automation Plan, then it means this request execution is currently
    	// at the front of the queue and needs to be removed
    	if (AutoRequestQueues.queueExists(autoPlanId))
    	{
    		AutoRequestQueues.popFirst(autoPlanId);
    	}
    }

	// End of user code

    public static void contextInitializeServletListener(final ServletContextEvent servletContextEvent)
    {
        
        // Start of user code contextInitializeServletListener
	
    	// load configuration
    	try {
    		VeriFitAnalysisProperties.loadProperties();
    	} catch (IOException e) {
			System.out.println("ERROR: Adapter configuration: Failed to load Java properties: " + e.getMessage());
			System.exit(1);
		}

    	// connect to the triplestore
    	String sparqlQueryEndpoint = VeriFitAnalysisProperties.SPARQL_SERVER_QUERY_ENDPOINT;
    	String sparqlUpdateEndpoint = VeriFitAnalysisProperties.SPARQL_SERVER_UPDATE_ENDPOINT; 
		try {
			store = new Persistence(sparqlQueryEndpoint, sparqlUpdateEndpoint);
		} catch (IOException e) {
			System.out.println("ERROR: Adapter configuration: " + e.getMessage());
			System.exit(1);
		}

    	// create AutomationPlans
		try {
			AutomationPlanLoading.loadAutomationPlans();
		} catch (StoreAccessException e) {
			System.out.println("ERROR: Adapter initialization: AutomationPlan creation: " + e.getMessage());
			System.exit(1);
		}
		
		// check what the last AutomationRequest ID is
    	// requests have a numerical ID
    	int initReqId = 0;
    	try {
			List<AutomationRequest> listAutoRequests =  store.getResources(new URI(VeriFitAnalysisProperties.SPARQL_SERVER_NAMED_GRAPH_RESOURCES), AutomationRequest.class);
			for (AutomationRequest autoReq : listAutoRequests)
			{
				int reqId = Integer.parseInt(utils.getResourceIdFromUri(autoReq.getAbout()));
				if ( reqId >= initReqId)
				{
					initReqId = reqId + 1;
				}
			}		
		} catch (StoreAccessException e) { 
			System.out.println("ERROR: Adapter initialization: Failed to get latest AutomationRequest ID: " + e.getMessage());
			System.exit(1);
			
		} catch (URISyntaxException e) {
			// TODO should never be thrown (URI syntax)
			e.printStackTrace();
		}		
		AutoRequestIdGen = new ResourceIdGen(initReqId);
    	
        // End of user code
    }

    public static void contextDestroyServletListener(ServletContextEvent servletContextEvent) 
    {
        
        // Start of user code contextDestroyed
        // End of user code
    }

    public static ServiceProviderInfo[] getServiceProviderInfos(HttpServletRequest httpServletRequest)
    {
        ServiceProviderInfo[] serviceProviderInfos = {};
        
        // Start of user code "ServiceProviderInfo[] getServiceProviderInfos(...)"

        ServiceProviderInfo r1 = new ServiceProviderInfo();
        r1.name = "VeriFit Analysis Provider";
        r1.serviceProviderId = VeriFitAnalysisConstants.AUTOMATION_PROVIDER_ID;

        serviceProviderInfos = new ServiceProviderInfo[1];
        serviceProviderInfos[0] = r1;

        // End of user code
        return serviceProviderInfos;
    }

    public static List<AutomationPlan> queryAutomationPlans(HttpServletRequest httpServletRequest, final String serviceProviderId, String where, int page, int limit)
    {
        List<AutomationPlan> resources = null;
        
        // Start of user code queryAutomationPlans
		resources = new ArrayList<AutomationPlan>();
        try {

	    	resources = store.whereQuery(httpServletRequest, new URI(VeriFitAnalysisProperties.SPARQL_SERVER_NAMED_GRAPH_RESOURCES), AutomationPlan.class, where, page, limit);

		} catch (URISyntaxException e) {
			// TODO should never be thrown (URI syntax)
			e.printStackTrace();
			
		} catch (StoreAccessException e) {
			System.out.println("WARNING: AutomationPlan query failed: " + e.getMessage());
		}
        // End of user code
        return resources;
    }
    public static List<AutomationRequest> queryAutomationRequests(HttpServletRequest httpServletRequest, final String serviceProviderId, String where, int page, int limit)
    {
        List<AutomationRequest> resources = null;
        
        // Start of user code queryAutomationRequests
		resources = new ArrayList<AutomationRequest>();
        try {
        	
	    	resources = store.whereQuery(httpServletRequest, new URI(VeriFitAnalysisProperties.SPARQL_SERVER_NAMED_GRAPH_RESOURCES), AutomationRequest.class, where, page, limit);

		} catch (StoreAccessException e) {
			System.out.println("WARNING: AutomationRequest query failed: " + e.getMessage());
			
		} catch (URISyntaxException e) {
			// TODO should never be thrown (URI syntax)
			e.printStackTrace();
		}
        // End of user code
        return resources;
    }
    public static List<AutomationResult> queryAutomationResults(HttpServletRequest httpServletRequest, final String serviceProviderId, String where, int page, int limit)
    {
        List<AutomationResult> resources = null;
        
        // Start of user code queryAutomationResults
		resources = new ArrayList<AutomationResult>();
        try {
        	
        	resources = store.whereQuery(httpServletRequest, new URI(VeriFitAnalysisProperties.SPARQL_SERVER_NAMED_GRAPH_RESOURCES), AutomationResult.class, where, page, limit);
	    	
		} catch (StoreAccessException e) {
			System.out.println("WARNING: AutomationResult query failed: " + e.getMessage());
			
		} catch (URISyntaxException e) {
			// TODO should never be thrown (URI syntax)
			e.printStackTrace();
		}
        // End of user code
        return resources;
    }
    public static List<AutomationPlan> AutomationPlanSelector(HttpServletRequest httpServletRequest, final String serviceProviderId, String terms)   
    {
        List<AutomationPlan> resources = null;
        
        // Start of user code AutomationPlanSelector
        
        resources = queryAutomationPlans(httpServletRequest, serviceProviderId, terms, 0, 20);
        
        // End of user code
        return resources;
    }
    public static List<AutomationRequest> AutomationRequestSelector(HttpServletRequest httpServletRequest, final String serviceProviderId, String terms)   
    {
        List<AutomationRequest> resources = null;
        
        // Start of user code AutomationRequestSelector
        
        resources = queryAutomationRequests(httpServletRequest, serviceProviderId, terms, 0, 20);       
        
        // End of user code
        return resources;
    }
    public static List<AutomationResult> AutomationResultSelector(HttpServletRequest httpServletRequest, final String serviceProviderId, String terms)   
    {
        List<AutomationResult> resources = null;
        
        // Start of user code AutomationResultSelector
        
        resources = queryAutomationResults(httpServletRequest, serviceProviderId, terms, 0, 20);
        
        // End of user code
        return resources;
    }
    public static AutomationRequest createAutomationRequest(HttpServletRequest httpServletRequest, final AutomationRequest aResource, final String serviceProviderId) throws OslcResourceException
    {
        AutomationRequest newResource = null;
        
        // Start of user code createAutomationRequest
 
		try {
			// error response on empty creation POST
	        if (aResource == null)
				throw new OslcResourceException("empty creation POST");
	        
	        // check for missing required properties
			if (aResource.getExecutesAutomationPlan().getValue() == null)
				throw new OslcResourceException("executesAutomationPlan property missing");
			if (aResource.getTitle() == null || aResource.getTitle().isEmpty())
				throw new OslcResourceException("title property missing");
	        
			// copy the properties specified in the POST request
			String newID = AutoRequestIdGen.getId();
			newResource = aResource;
			newResource.setAbout(VeriFitAnalysisResourcesFactory.constructURIForAutomationRequest(serviceProviderId, newID));
			
			// resources set by the service provider
			newResource.setIdentifier(newID);
			Date timestamp = new Date();
			newResource.setCreated(timestamp);
			newResource.setModified(timestamp);
			//newResource.setInstanceShape(new URI(AnacondaAdapterConstants.PATH_RESOURCE_SHAPES + "automationRequest"));
			//newResource.addServiceProvider(new URI(AnacondaAdapterConstants.PATH_AUTOMATION_SERVICE_PROVIDERS + serviceProviderId));
			newResource.setDesiredState(new Link(new URI(VeriFitAnalysisConstants.AUTOMATION_STATE_COMPLETE)));
			//newResource.addType(new URI("http://open-services.net/ns/auto#AutomationRequest"));
			

			// create an AutomationResult for this AutoRequest; output parameters will be set by processAutoReqInputParams()
			AutomationResult propAutoResult = new AutomationResult();
			propAutoResult.setTitle("Result - " + newResource.getTitle());
			propAutoResult.setReportsOnAutomationPlan(newResource.getExecutesAutomationPlan());
			propAutoResult.setProducedByAutomationRequest(VeriFitAnalysisResourcesFactory.constructLinkForAutomationRequest(serviceProviderId, newID));
			propAutoResult.setInputParameter(newResource.getInputParameter());
			propAutoResult.setContributor(newResource.getContributor());
			propAutoResult.setCreator(newResource.getCreator());
			propAutoResult.addVerdict(new Link(new URI(VeriFitAnalysisConstants.AUTOMATION_VERDICT_UNAVAILABLE)));
			
			// get the executed autoPlan, check input parameters, add output parameters to the AutoResult, and make an input map for the runner
			Map<String, Pair<String,Integer>> inputParamsMap = processAutoReqInputParams(serviceProviderId, newResource, propAutoResult);
			
			// check that the SUT to be executed exists
			OslcClient client = new OslcClient();
			ClientResponse response = client.getResource(inputParamsMap.get("SUT").getLeft());
			if (response.getStatusCode() != 200)
			{
				throw new IOException("Failed to get refferenced SUT - make sure the compilation provider is running.\nResponse status code: " + response.getStatusCode() + "\nMessage: "+ response.getMessage());
			}
			SUT executedSUT = response.getEntity(SUT.class);
			
			// check if the SUT launch command or the SUT build command should be used and get it from the SUT
			Pair<String,Integer> launchSUT = inputParamsMap.get("launchSUT");
			Pair<String,Integer> SUTbuildCommand = inputParamsMap.get("SUTbuildCommand");
			if (launchSUT != null)
			{
				String launchCmd = executedSUT.getLaunchCommand();
				if (launchCmd == null)
					throw new OslcResourceException("paramer launchSUT - referenced SUT is missing a launchCommand");
				else	
					inputParamsMap.put("launchSUT", Pair.of(launchCmd, Integer.parseInt(launchSUT.getLeft())));
			}
			if (SUTbuildCommand != null)
			{
				String buildCmd = executedSUT.getBuildCommand();
				if (buildCmd == null)
					throw new OslcResourceException("paramer SUTbuildCommand - referenced SUT is missing a buildCommand");
				else	
					inputParamsMap.put("SUTbuildCommand", Pair.of(buildCmd, Integer.parseInt(SUTbuildCommand.getLeft())));
			}

			if (launchSUT != null || SUTbuildCommand != null)
			{
				// modify the output parameters of the automation result (was added by processAutoReqInputParams)
				for (ParameterInstance param : propAutoResult.getOutputParameter())
				{
					if (param.getName().equals("launchSUT"))
					{
						param.setValue(executedSUT.getLaunchCommand());
					}
					else if (param.getName().equals("SUTbuildCommand"))
					{
						param.setValue(executedSUT.getBuildCommand());
					}
				}
			}

			// load the automation plan's configuration from the conf. manager
			Boolean oneInstanceOnly = AutomationPlanConfManager.getInstance()
					.getAutoPlanConf(getResourceIdFromUri(newResource.getExecutesAutomationPlan().getValue()))
					.getOneInstanceOnly();

			// check whether the new Auto Request can start execution immediately or needs to wait in a queue
			// and set its state accordingly (same for the Auto Result)
			String requestState;
			if (oneInstanceOnly == false) // no instance restrictions --> can run
			{
				requestState = VeriFitAnalysisConstants.AUTOMATION_STATE_INPROGRESS;
			}
			else	// only one instance allowed at a time --> check queue
			{
				requestState = VeriFitAnalysisConstants.AUTOMATION_STATE_QUEUED;
			}			
			newResource.addState(new Link(new URI(requestState)));
			propAutoResult.addState(new Link(new URI(requestState)));
			
			// persist the AutomationResult and set the setProducedAutomationResult() link for the AutoRequest
		    AutomationResult newAutoResult = VeriFitAnalysisManager.createAutomationResult(propAutoResult, serviceProviderId, newID);
			newResource.setProducedAutomationResult(new Link(newAutoResult.getAbout())); // TODO

			// persist the new AutoRequest in the triplestore
			store.updateResources(new URI(VeriFitAnalysisProperties.SPARQL_SERVER_NAMED_GRAPH_RESOURCES), newResource);
			
			// create a new thread to execute the automation request - and start it OR queue it up
			SutAnalyse runner = new SutAnalyse(serviceProviderId, newResource, newAutoResult, executedSUT, inputParamsMap);
			if (requestState.equals(VeriFitAnalysisConstants.AUTOMATION_STATE_INPROGRESS))
			{
				runner.start();
			}
			else	
			{
				AutoRequestQueues.queueUp(
						utils.getResourceIdFromUri(newResource.getExecutesAutomationPlan().getValue()),
						runner);
			}
			
			
		} catch (OslcResourceException | RuntimeException | IOException e) {
			throw new OslcResourceException("AutomationRequest NOT created - " + e.getMessage());
			
		} catch (URISyntaxException e) {
			// TODO should never be thrown (URI syntax)
			e.printStackTrace();
			
		} catch (Exception e) {
			System.out.println("WARNING: AutomationResquest creation failed: " + e.getMessage());
			throw new OslcResourceException("AutomationRequest NOT created - " + e.getMessage());
		}
		
        // End of user code
        return newResource;
    }

    public static AutomationRequest createAutomationRequestFromDialog(HttpServletRequest httpServletRequest, final AutomationRequest aResource, final String serviceProviderId)
    {
        AutomationRequest newResource = null;
        
        // Start of user code createAutomationRequestFromDialog
        
        try {
			newResource = createAutomationRequest(httpServletRequest,aResource, serviceProviderId);
		} catch (OslcResourceException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        
        // End of user code
        return newResource;
    }

    public static AutomationPlan getAutomationPlan(HttpServletRequest httpServletRequest, final String serviceProviderId, final String automationPlanId)
    {
        AutomationPlan aResource = null;
        
        // Start of user code getAutomationPlan

        URI resUri = VeriFitAnalysisResourcesFactory.constructURIForAutomationPlan(serviceProviderId, automationPlanId);
        try {

        	aResource = store.getResource(new URI(VeriFitAnalysisProperties.SPARQL_SERVER_NAMED_GRAPH_RESOURCES), resUri, AutomationPlan.class);

        } catch (URISyntaxException e) {
			// TODO should never be thrown (URI syntax)
			e.printStackTrace();
			
		} catch (NoSuchElementException e) {
			aResource = null;
			
		} catch (StoreAccessException e) {
			System.out.println("WARNING: AutomationPlan GET failed: " + e.getMessage());
		}
        
        // End of user code
        return aResource;
    }


    public static AutomationRequest getAutomationRequest(HttpServletRequest httpServletRequest, final String serviceProviderId, final String automationRequestId)
    {
        AutomationRequest aResource = null;
        
        // Start of user code getAutomationRequest

        URI resUri = VeriFitAnalysisResourcesFactory.constructURIForAutomationRequest(serviceProviderId, automationRequestId);
        try {
        	
			aResource = store.getResource(new URI(VeriFitAnalysisProperties.SPARQL_SERVER_NAMED_GRAPH_RESOURCES), resUri, AutomationRequest.class);

        } catch (URISyntaxException e) {
			// TODO should never be thrown (URI syntax)
			e.printStackTrace();
			
		} catch (NoSuchElementException e) {
			aResource = null;
			
		} catch (StoreAccessException e) {
			System.out.println("WARNING: AutomationRequest GET failed: " + e.getMessage());
		}
        
        // End of user code
        return aResource;
    }


    public static AutomationResult getAutomationResult(HttpServletRequest httpServletRequest, final String serviceProviderId, final String automationResultId)
    {
        AutomationResult aResource = null;
        
        // Start of user code getAutomationResult

        URI resUri = VeriFitAnalysisResourcesFactory.constructURIForAutomationResult(serviceProviderId, automationResultId);
        try {
        	
			aResource = store.getResource(new URI(VeriFitAnalysisProperties.SPARQL_SERVER_NAMED_GRAPH_RESOURCES), resUri, AutomationResult.class);

        } catch (URISyntaxException e) {
			// TODO should never be thrown (URI syntax)
			e.printStackTrace();
			
		} catch (NoSuchElementException e) {
			aResource = null;
			
		} catch (StoreAccessException e) {
			System.out.println("WARNING: AutomationResult GET failed: " + e.getMessage());
		}
        
        // End of user code
        return aResource;
    }






    public static String getETagFromAutomationPlan(final AutomationPlan aResource)
    {
        String eTag = null;
        // Start of user code getETagFromAutomationPlan
        
        if (aResource != null && aResource.getModified() != null)
        	eTag = Long.toString(aResource.getModified().getTime());
        
        // End of user code
        return eTag;
    }
    public static String getETagFromAutomationRequest(final AutomationRequest aResource)
    {
        String eTag = null;
        // Start of user code getETagFromAutomationRequest
        
        if (aResource != null && aResource.getModified() != null)
        	eTag = Long.toString(aResource.getModified().getTime());
        
        // End of user code
        return eTag;
    }
    public static String getETagFromAutomationResult(final AutomationResult aResource)
    {
        String eTag = null;
        // Start of user code getETagFromAutomationResult
        
        if (aResource != null && aResource.getModified() != null)
        	eTag = Long.toString(aResource.getModified().getTime());
        
        // End of user code
        return eTag;
    }
    public static String getETagFromContribution(final Contribution aResource)
    {
        String eTag = null;
        // Start of user code getETagFromContribution
        // TODO Implement code to return an ETag for a particular resource
        // End of user code
        return eTag;
    }

}
